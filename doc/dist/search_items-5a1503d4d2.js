searchNodes=[{"doc":"Calculates availability of stores.","ref":"Availabilities.html","title":"Availabilities","type":"module"},{"doc":"Returns the availability for a given store, or empty if the store is closed","ref":"Availabilities.html#build/2","title":"Availabilities.build/2","type":"function"},{"doc":"Contains the availabilities of a store for the given day. Will be empty if the store is closed.","ref":"Availabilities.Availability.html","title":"Availabilities.Availability","type":"module"},{"doc":"The availability","ref":"Availabilities.Availability.html#t:t/0","title":"Availabilities.Availability.t/0","type":"type"},{"doc":"Parameters passed to the Availabilities build funciton. Encompasses the settings for timeslots and schedules.","ref":"Availabilities.Params.html","title":"Availabilities.Params","type":"module"},{"doc":"The parameters","ref":"Availabilities.Params.html#t:t/0","title":"Availabilities.Params.t/0","type":"type"},{"doc":"Schedules the days when a store is open and for how long.","ref":"Availabilities.Schedule.html","title":"Availabilities.Schedule","type":"module"},{"doc":"A schedule","ref":"Availabilities.Schedule.html#t:t/0","title":"Availabilities.Schedule.t/0","type":"type"},{"doc":"Data structure representing recurrence and duration of a given time slot. Slot duration can be greater then slot recurrence, allowing slots to overlap.","ref":"Availabilities.TimeSlotSettings.html","title":"Availabilities.TimeSlotSettings","type":"module"},{"doc":"A time slot setting","ref":"Availabilities.TimeSlotSettings.html#t:t/0","title":"Availabilities.TimeSlotSettings.t/0","type":"type"},{"doc":"Store Availability KataStore managers and end consumers of our e-commerce started asking our imaginary store for a way to have their orders scheduled at checkout, so that managers could better prepare their inventory for a given date and time and consumers could better know the time window they should wait for couriers to arrive at their location.In order to meet this growing need from our user base we need to create a simple booking system and, as one of the core features of this system, we will need a module to calculate and return the available time slots for a given date, considering the store's schedule plus some additional params. This would ideally be a standalone module that would work pretty much like a lib imported into the main codebase and so far we only have a name for it (Availabilities) and some definitions for its API as we can see below:Input structs:# Settings for building time slots: settings = %Availabilities.TimeSlotSettings{ slot_recurrence: 3600, # Time interval in seconds between successive availability slots e.g. 3600 =&gt; time slots: 09:00, 10:00, 11:00, ... slot_duration: 3600, # Duration of a booking in seconds. In our case it&#39;s the delivery time window for a scheduled order } # Store&#39;s weekly schedule: schedules = [ %Availabilities.Schedule{ weekday: :monday, # Week day in the weekly schedule start_time: ~T[09:00:00], # Time when the store opens end_time: ~T[18:00:00] # Time when the store closes }, ... ] # Params for calculating and building time slot availabilities: params = %Availabilities.Params{ settings: settings, schedules: schedules } Output struct:# Resulting struct with availabilities for a date: %Availabilities.Availability{ date: ~D[2021-05-03], weekday: :monday, slots: [ %{ start_time: ~T[09:00:00], # Time slot start time end_time: ~T[10:00:00] # Time slot end time }, %{ start_time: ~T[10:00:00], end_time: ~T[11:00:00] }, ... ] }Knowing these data structures, now we need you to implement the Availabilities.build/2 function, the one that will actually calculate and return time slot availabilities based on a date and params passed as its arguments (more in the example below).Sample Inputssettings = %Availabilities.TimeSlotSettings{ slot_recurrence: 7200, slot_duration: 3600 } schedules = [ %Availabilities.Schedule{ weekday: :monday, start_time: ~T[09:00:00], end_time: ~T[18:00:00] }, %Availabilities.Schedule{ weekday: :wednesday, start_time: ~T[13:00:00], end_time: ~T[18:00:00] }, %Availabilities.Schedule{ weekday: :friday, start_time: ~T[09:00:00], end_time: ~T[13:00:00] } ] params = %Availabilities.Params{ settings: settings, schedules: schedules }Expected Outputs1) Availabilities for a Monday in the future:iex&gt; Availabities.build(params, ~D[2021-05-03]) [ %Availabities.Availability{ date: ~D[2021-05-03], weekday: :monday, slots: [ %{ start_time: ~T[09:00:00], end_time: ~T[10:00:00] }, %{ start_time: ~T[11:00:00], end_time: ~T[12:00:00] }, %{ start_time: ~T[13:00:00], end_time: ~T[14:00:00] }, %{ start_time: ~T[15:00:00], end_time: ~T[16:00:00] }, %{ start_time: ~T[17:00:00], end_time: ~T[18:00:00] } ] } ]2) Availabilities for a Wednesday in the future:iex&gt; Availabities.build(params, ~D[2021-06-16]) [ %Availabities.Availability{ date: ~D[2021-06-16], weekday: :wednesday, slots: [ %{ start_time: ~T[13:00:00], end_time: ~T[14:00:00] }, %{ start_time: ~T[15:00:00], end_time: ~T[16:00:00] }, %{ start_time: ~T[17:00:00], end_time: ~T[18:00:00] } ] } ]3) Availabilities for a Friday in the future:iex&gt; Availabities.build(params, ~D[2021-07-30]) [ %Availabities.Availability{ date: ~D[2021-07-30], weekday: :friday, slots: [ %{ start_time: ~T[09:00:00], end_time: ~T[10:00:00] }, %{ start_time: ~T[11:00:00], end_time: ~T[12:00:00] } ] } ]4) Availabilities for a date with no daily schedule:iex&gt; Availabities.build(params, ~D[2021-07-29]) []","ref":"readme.html","title":"Store Availability Kata","type":"extras"},{"doc":"If available in Hex, the package can be installed by adding availabilities to your list of dependencies in mix.exs:def deps do [ {:availabilities, &quot;~&gt; 0.1.0&quot;} ] end","ref":"readme.html#installation","title":"Store Availability Kata - Installation","type":"extras"}]